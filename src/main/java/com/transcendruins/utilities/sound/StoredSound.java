/* Copyright 2025 Evan Troxell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.transcendruins.utilities.sound;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.UnsupportedAudioFileException;

import com.transcendruins.utilities.files.TracedPath;

/**
 * <code>StoredSound</code>: A class representing a store sound.
 */
public final class StoredSound {

    /**
     * <code>int</code>: The file size threshold of 5 MB to determine which format a
     * sound should be processed into.
     */
    public static final int LARGE_FILE_THRESHOLD = 5 * 1024 * 1024;

    /**
     * <code>TracedPath</code>: The filepath leading to this
     * <code>StoredSound</code> instance.
     */
    private final TracedPath path;

    /**
     * <code>PlayableSound</code>: The sound generated by this
     * <code>StoredSound</code> instance, either representing a sound stored in
     * memory or a sound streamed from disk.
     */
    private final PlayableSound sound;

    /**
     * Creates a new instance of the <code>StoredSound</code> class.
     * 
     * @param path <code>TracedPath</code>: The filepath leading to this
     *             <code>StoredSound</code> instance.
     * @throws UnsupportedAudioFileException Thrown if the audio file is of an
     *                                       invalid format.
     * @throws IOException                   Thrown if the file could not be
     *                                       processed.
     */
    public StoredSound(TracedPath path) throws UnsupportedAudioFileException, IOException {

        this.path = path;

        boolean isLargeFile = path.getSize() > LARGE_FILE_THRESHOLD;

        sound = isLargeFile ? new StreamSound() : new ClipSound();
    }

    public final double toDecibels(double volumePct) {

        if (volumePct < 0.0)
            volumePct = 0.0;
        return 20.0 * Math.log10(volumePct / 100.0);
    }

    /**
     * Plays this <code>StoredSound</code> instance.
     * 
     * @return <code>boolean</code>: Whether or not this <code>StoredSound</code>
     *         played.
     */
    public final boolean play() {

        return sound.run(0);
    }

    /**
     * Plays this <code>StoredSound</code> instance.
     * 
     * @param volumePct <code>double</code>: The volume percent to play this
     *                  <code>StoredSound</code> instance at, ranging from 0% to
     *                  200%.
     * @return <code>boolean</code>: Whether or not this <code>StoredSound</code>
     *         played.
     */
    public final boolean play(double volumePct) {

        return sound.run((float) toDecibels(volumePct));
    }

    /**
     * <code>PlayableSound</code>: An interface representing a sound which can be
     * run.
     */
    @FunctionalInterface
    private interface PlayableSound {

        /**
         * Runs this <code>PlayableSound</code> instance.
         * 
         * @param decibels <code>float</code>: The decibel volume of the sound to play,
         *                 beginning at <code>0.0</code> for the original volume.
         * @return <code>boolean</code>: If the sound successfully ran without
         *         exception.
         */
        public boolean run(float decibels);
    }

    /**
     * <code>ClipSound</code>: A class representing a sound stored in a clip in
     * memory.
     */
    private final class ClipSound implements PlayableSound {

        /**
         * <code>byte[]</code>: The audio data of this <code>ClipSound</code> instance
         * represented as a byte array.
         */
        private final byte[] audioData;

        /**
         * <code>AudioFormat</code>: The audio format of this <code>ClipSound</code>
         * instance.
         */
        private final AudioFormat format;

        /**
         * Creates a new instance of the <code>ClipSound</code> class.
         * 
         * @throws UnsupportedAudioFileException Thrown if the audio file is of an
         *                                       invalid format.
         * @throws IOException                   Thrown if the file could not be
         *                                       processed.
         */
        public ClipSound() throws IOException, UnsupportedAudioFileException {

            try (InputStream inputStream = path.getInputStream();
                    AudioInputStream audioStream = AudioSystem.getAudioInputStream(inputStream)) {

                format = audioStream.getFormat();
                audioData = path.getBytes();
            }
        }

        @Override
        public final boolean run(float decibels) {

            try (AudioInputStream audioStream = new AudioInputStream(new ByteArrayInputStream(audioData), format,
                    audioData.length / format.getFrameSize()); Clip clip = AudioSystem.getClip();) {

                clip.open(audioStream);

                if (clip.isControlSupported(FloatControl.Type.MASTER_GAIN)) {

                    FloatControl gainControl = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);
                    decibels = Math.clamp(decibels, gainControl.getMinimum(), gainControl.getMaximum());
                    gainControl.setValue(decibels);
                }

                clip.start();

                return true;
            } catch (LineUnavailableException | IOException e) {

                return false;
            }
        }
    }

    /**
     * <code>StreamSound</code>: A class representing a sound which should be
     * streamed from disk.
     */
    private final class StreamSound implements PlayableSound {

        @Override
        public final boolean run(float decibels) {

            try (InputStream inputStream = path.getInputStream();
                    AudioInputStream audioStream = AudioSystem.getAudioInputStream(inputStream);
                    SourceDataLine line = (SourceDataLine) AudioSystem
                            .getLine(new DataLine.Info(SourceDataLine.class, audioStream.getFormat()))) {

                AudioFormat format = audioStream.getFormat();
                line.open(format);
                if (line.isControlSupported(FloatControl.Type.MASTER_GAIN)) {

                    FloatControl gainControl = (FloatControl) line.getControl(FloatControl.Type.MASTER_GAIN);
                    decibels = Math.clamp(decibels, gainControl.getMinimum(), gainControl.getMaximum());
                    gainControl.setValue(decibels);
                }
                line.start();

                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead = audioStream.read(buffer)) != -1) {
                    line.write(buffer, 0, bytesRead);
                }

                line.drain();

                return true;
            } catch (Exception e) {

                return false;
            }
        }
    }
}
